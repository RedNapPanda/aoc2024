use std::ops::Add;
use crate::utils::grid::Grid;
use crate::utils::point::Point;
use itertools::Itertools;
use regex::Regex;

#[derive(Clone, Debug)]
struct Robot {
    position: Point,
    velocity: Point,
}

impl Robot {
    fn walk(&mut self, height: i64, width: i64) {
        self.position += &self.velocity;
        if self.position.x < 0 {
            self.position.x += height;
        } else if self.position.x >= height {
            self.position.x %= height;
        }
        if self.position.y < 0 {
            self.position.y += width;
        } else if self.position.y >= width {
            self.position.y %= width;
        }
    }
}

pub fn solve1(lines: &[String]) -> i64 {
    let (height, width) = (103i64, 101i64);
    let mut robots = parse(lines);
    for robot in &mut robots {
        let x100 = robot.position.x + 100 * robot.velocity.x;
        let y100 = robot.position.y + 100 * robot.velocity.y;
        robot.position.x = if x100 < 0 {
            height - (!x100 % height) - 1
        } else {
            x100 % height
        };
        robot.position.y = if y100 < 0 {
            width - (!y100 % width) - 1
        } else {
            y100 % width
        };
    }
    let mid_height = height / 2;
    let mid_width = width / 2;
    let mut quadrants = [0; 4];
    for robot in &robots {
        let pos = &robot.position;
        if pos.x == mid_height || pos.y == mid_width {
            continue;
        }
        let quadrant = (pos.x > mid_height) as usize * 2 + (pos.y > mid_width) as usize;
        quadrants[quadrant] += 1;
    }
    quadrants.iter().product::<i64>()
}

pub fn solve2(lines: &[String]) -> i64 {
    let (height, width) = (103i64, 101i64);
    let mut grid = Grid::<usize>::with_dimensions(height as usize, width as usize);
    let mut robots = parse(lines);
    for x in 0..(103*101) {
        grid.reset_defaults();
        for robot in &mut robots {
            robot.walk(height, width);
            grid.set(&robot.position, grid.get(&robot.position).unwrap_or(&0) + 1);
        }
        // printing all grids with no overlap.
        // hint-word was 'most' robots (though they could have technically overlapped anyways...)
        // this was clearly a trick question... to find a cycle
        // I feel like this wasn't supposed to work...
        // if !grid.iter().flatten().any(|&v| v > 1) {
        //     return x + 1;
        // }
        // Since the tree has big horizontal lines
        // 00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
        // 00001000000000000000000000000000001111111111111111111111111111111000000000000000000000000000000000000
        // 00000000000000000000000000000000001000000000000000000000000000001000000000000000000000000000000000000
        // 00000000000000000000000000000000001000000000000000000000000000001000000000000000000000000100000000000
        // 00000000000000000000000000001000001000000000000000000000000000001000000000000000000000000000000000000
        // 00000000000000000000000100000000001000000000000000000000000000001000000000000000000000000000000000000
        // 00000000000000000000000000000000001000000000000001000000000000001000000000000000000100000000000000000
        // 00000000000000000000000000000000001000000000000011100000000000001000000000000000000000000000000000000
        // 00000000000000000000000000000000001000000000000111110000000000001000000000000000000000000000000000000
        // 00000000000000000000010000000000001000000000001111111000000000001000000000000000000000000000000000000
        // 00000000000000000000000000000000001000000000011111111100000000001000000000000000000000000000000000000
        // 00000000000000000000010000000000001000000000000111110000000000001000000000000000000000001000000000000
        // 00000000100000000000000000000000001000000000001111111000000000001000000000000000000000000000000000000
        // 00000000000000000000000000000000001000000000011111111100000000001000000000000000000000000000000100000
        // 00000000000000000000000000000000001000000000111111111110000000001000000000000000000001000000000000000
        // 00000000000000000000000000000000001000000001111111111111000000001000000000000000000000000000000000000
        // 00000000000000000000000000000000001000000000011111111100000000001000000000100000000001000000000000000
        // 00000000000000000000000000000010001000000000111111111110000000001000000000000000000000000000000000000
        // 00000000000000000000000000000001001000000001111111111111000000001000000000000000010000000000000000000
        // 00000000000000000000000000000000001000000011111111111111100000001000000000000000000000000100000000000
        // 00000000000000000000000000000001001000000111111111111111110000001000000000000000000000000000000000000
        // 00000000000000000001000000000000001000000001111111111111000000001000000000000000000000000000000000000
        // 00000000000000000010000000000000001000000011111111111111100000001000000000000010000000000000000000000
        // 00000000000000000000000000000000001000000111111111111111110000001000000000000000000000000000000000000
        // 00000000000000000000000000000000001000001111111111111111111000001000000000000000000000000000000000000
        // 00000000000000100000000000000000001000011111111111111111111100001000000000000000000000000000000000000
        // 00000000000000000000000000000000001000000000000011100000000000001000000000000000000000000000000000000
        // 00001000000000100000000000000000001000000000000011100000000000001000000000000000000000000000000000000
        // 10000010000000000000000000000000001000000000000011100000000000001000000000000000100000000000000000000
        // 00000000000001000000000000000000001000000000000000000000000000001000000000000000000000000000000000000
        // 00000000000000000000000000001000001000000000000000000000000000001000000000000000000000000000000000000
        // 00000000000000000000000000000000001000000000000000000000000000001000000000000000000000000000000000000
        // 00000000000000000000000000000000001000000000000000000000000000001000000000000000000000000000000010000
        // 00000000000000000000000000000000001111111111111111111111111111111000000000000000000000000000000000000
        // 00000000000000000000000000000000000000000000000000000000000000000001000000000000000010000000000000000
        
        for robot in &mut robots {
            if 9 == (1..10)
                .take_while(|&i| grid.get(&robot.clone().position.add((0, i))).is_some_and(|&i|i == 1))
                .count() {
                return x + 1
            }
        }
    }
    unreachable!()
}

fn parse(lines: &[String]) -> Vec<Robot> {
    let regex = Regex::new("p=(-?\\d+),(-?\\d+) v=(-?\\d+),(-?\\d+)").unwrap();
    lines
        .iter()
        .flat_map(move |l| {
            regex
                .captures_iter(l)
                .map(|captures| {
                    // directions are transposed to natural layout where x=row, y=col
                    // x -> right | y -> down == array[y][x]
                    // vs
                    // x -> down | y -> right == array[x][y]
                    let py = captures[1].parse::<i64>().unwrap();
                    let px = captures[2].parse::<i64>().unwrap();
                    let vy = captures[3].parse::<i64>().unwrap();
                    let vx = captures[4].parse::<i64>().unwrap();
                    let position = Point::from((px, py));
                    let velocity = Point::from((vx, vy));
                    Robot { position, velocity }
                })
                .collect_vec()
        })
        .collect_vec()
}
